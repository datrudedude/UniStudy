import statistics

# Из таблицы к варианту №7
READ_SIZE = 16
GROUP_SIZE = 13
BYTE_BASIS = 11


# Суть алгоритма: Считываем 2 стандартных байта(16 бит) инфы, и просто отсекаем 11 бит справа и записываем как
# десятичное число в динамический массив, а то что осталось записываем в tail, дабы использовать на след. итерации.
# Далее считываем новые 16 бит, отсекаем от них (11 - количество записанных битов в tail) бит справа, конкатенируем к
# ним биты из tail справа и снова записываем как десятичное число в динамический массив, и так пока не получим массив
# с 13 элементами, после чего сортируем, считаем медиану в этом ряду чисел из массива, с помощью функции из
# стандартной библиотеки, и считаем разницу медианы со всеми остальными элементами, а дальше пишем строку в файл,
# и так по кругу, ибо не указано сколько данных всего передадут. НЕБОЛЬШОЕ ПОЯСНЕНИЕ КАСАТЕЛЬНО ПОБИТОВЫХ ОПЕРАЦИЙ:
# !Вся работа с отсечением битов, это работа со строками, да можно было бы использовать и стандартные битовые
# операции операции, и высчитывать модуль и целочисленное деление, но в рот оно ебись, так как 1) в питоне с
# примитивными типами данных вообше беда, 2) остаются проблемы с записью ведущих нулей, ну и 3) главное что работает и
# быстро, условия к написанию проги выполнены, никаких другие библиотеки, кроме стандартных не используются!

def got_from_pipe(url):  # Не понял, какая именно передается ссылка на канал, но раз канал создает ос, то предположил что это url файла
    r = open(url)
    while True:  # В условии сказано, что передается по анонимному каналу в реальном времени и ограничений вроде как нет на кол-во информации, так что цикл бесконечный
        group = []  # Сюда будем группировать полученные последовательности
        tail = ""  # Сюда записываем остаток битов
        got = bin(int.from_bytes(r.read(READ_SIZE).encode(), 'big'))[2:].zfill(READ_SIZE)  # В стандартной библиотеке питона считывается как строка, поэтому переводим в байты и делаем чтоб красиво отображалось
        while len(group) < GROUP_SIZE:  # Набираем 13 элементов в массив
            res_num = ""  # Строка полученной последовательностью битов
            if len(tail) >= BYTE_BASIS:  # Если остаток с прошлой итерации больше чем 11, то работаем с ним
                res_num = tail[-BYTE_BASIS:]
                tail = tail[:-BYTE_BASIS]
            elif len(got) >= BYTE_BASIS:  # Если кол-во считанных битов больше 11(а так всегда, когда мы считываем новые данные из канала), то работаем с ними
                res_num = got[-(BYTE_BASIS - len(tail)):] + tail
                tail = got[:-(BYTE_BASIS - len(tail))]
                got = ""
            else:  # Ну а если считанных битов меньше 11, то просто прибавим к остатку и будем ждать пока не выполнится условие первое сверху
                tail = got + tail
                got = ""
            if len(res_num) != 0: group.append(int(res_num,  2))  # Если на этой итерации все таки получен последовательность из 11 битов (1 и 2 ветка if), то добавляем в массив
            if len(got) == 0: got = bin(int.from_bytes(r.read(READ_SIZE).encode(), 'big'))[2:].zfill(READ_SIZE * 8)  # Если мы обработали все полученные данные, то считываем новые
        else:  # Когда наберем 13 элементов, то начинаем расчеты
            group.sort()  # Сортируем
            median = statistics.median(group)  # Считаем медиану
            res = str(median)  # Подготавливаем строку которую будем записывать в файл
            for i in group:  # Перебираем все элементы масива,
                if i == median: continue  # кроме самой медианы,
                res = res + " " + str(abs(median - i))  # и считаем разницу с медианой и добавляем в строку
            # Пишем в файл
            my_file = open("some.txt", 'a')
            my_file.write(res + "\n")
            my_file.close()
